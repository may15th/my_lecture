# data types
## 개요
값의 종류와 그 값에 적용 가능한 연산과 동작을 결정하는 속성

### 데이터 타입이 필요한 이유
- 값들 구분, 어떻게 다뤄야 하는지 알 수 있음
- 타입을 명시적으로 지정하면 코드를 읽는 사람이 변수의 의도를 더 쉽게 이해할 수 있고, 잘못된 데이터 타입으로 인한 오류를 예방


### numeric types 수치형 타입
int, float, complex

int
진수표현
- 2진수(binary)
0b 30 = 8
- 8진수(octal)
0o 30 = # 24
- 16진수(hexadecimal)
0x 30 = 48

### float
유, 무리수, 소수

#### 유한 정밀도

컴퓨터 메모리 용량 한정돼 있고 한 숫자에 대해 저장하는 용량이 제한됨.
0.666666666 과 1.66666667은
제한된 양 메모리에 저장할 수 있는 2/3과 5/3에 가장 가까운 값


Floating point rounding error
메모리의 한계 때문에 무한대의 실수표현
연산의 문제다.
깊이 파고들 필요는 없다.
실수 연산할 때 조심하자.

# 지수(제곱하는 횟수) 표현 10^
e또는 E를 사용한 지수표현
314*0.01
number = 314e-2
print(314e-2) = #3.14
print(314e2) = 31400.0
print(314E2) 도 31400.0?? 확인필

# sequence types
여러 개의 값들을 !순서대로 나열!하여 저장하는 자료형
(str, list, tuple, range)


## Sequence Types의 특징
1. 순서(sequence)
 - 값들이 순서대로 저장(정렬x) 정렬은 아니다! 나열 되어 있을 뿐
 정렬 되어있는 것 아니다(시험 나올 듯..)
2. 인덱싱(indexing)
 - 각 값에 고유한 인덱스(번호)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정 가능
 3. 슬라이싱(slicing)
  - 인덱스 범위를 조절해 부분적인 값 추출할 수 있음.
4. 길이(length)
  - len() 함수를 사용하여 저장된 값의 개수(길이) 구할 수 있음.
5. 반복(iteration)
  - 반복문을 사용하여 저장된 값들을 반복적으로 처리할 수 있음.

길이는
그 안의 요소의 갯수가 길이이다.

## str
문자들의 순서가 있는 !변경 불가능한! 시퀀스 자료형(불변형 자료형)

- 작은 따옴표 또는 큰따옴표로 구현

스타일 가이드에서는 상관없는데 하나정한걸 쭉쓰라고 함. 작은따옴표로 시작했으면 끝까지 작은 따옴표

### 중첩 따옴표
- 따옴표 안에 따옴표를 표현할 경우
  -  작은 따옴표가 들어 있는 경우는 큰따옴표로 문자열 생성
  -큰 따옴표는 반대

### escape sequence
 - 역슬래쉬 뒤에 특정 문자가 와서 특수한 기능을 하는 문자 조합
 - 파이써의 일반적인 문법 규칙을 잠시 탈출한다느느 의미
 
 \n 줄바꿈
 \t 탭
 \\ 백슬래시
 \' 작은따옴표
 \"
 문법규칙을 잠시 탈출해서 독특한 역할을 하는 문자열

 print('철수야 /'안녕/'')

 print('이 다음은 엔터\n입니다.')


String Interpolation
문자열 내에 변수나 표현식을 삽입하는 방법(보간법)

문자열 안에서 변수나 표현식을 삽입하는 방법

## f-string
- 문자열에 f 또는 F 접두어를 부팅고 표현식을 {expression}로 작성하여 문자열에 파이썬 표현식의 값을 삽입할 수 있음.
- 문제 풀이중 가장 많이 사용하는 문법 증 하나.

# f-string
bugs = 'roaches'
counts = 13
area = 'livingroom'

print(f'Debugging {bugs}{counts}{area}') (f뒤에 바로붙여야됨 공백이나 콤마 있으면 인식안됌.)
print('Debugging {}{}{}', format(bugs, counts, area))
print('Debugging %s %d %s' % (bugs, counts, area))

#### f-string 응용
greeting = 'hi'
print(f'{greeting:^10}')
:^10이 중괄호 안에 들어감 기억.

#### 문자열의 시퀀스 특징

 my_str = 'hello'

#인덱싱

print(my_str[1]) #e

#슬라이싱

print(my_str[2:4]) #ll

#길이
print(len(my_str)) #5

## 인덱스

시퀀스 내의 값들에 대한 고유한 번호로, 각 값의 위치를 식별하는 데 사용되는 숫자.

h e l l o
0 1 2 3 4
-5-4-3-2-1

## 슬라이싱
- 시퀀스 일부분을 선탤하여 추출하는 작업
- 시작 인덱스와 끝 인덱스를 지정하여 해당 범위의 값을 포함하는 새로운 시퀀스 생성

처음, 끝 생략 가능
my_str[:3]
hel
my_str[3:]
lo
my_str[0:5:2]
      h l o
index 0 2 4

step으로 할 수있는 독특한 기능
mystr[::-1]
"olleh" 음수 스텝이라서 반대로 감
!슬라이싱으로 문자열 뒤집기!

파이썬에선 되게 간단한게 문자열 뒤집기 가능;;

## 문자열은 불변 자료형(변경불가)

my_str = 'hello'

#Type Error: 'str object does not supprt item assignment
my_str[1] = 'z'
불가@!@@!!

불변자료형은 새로운 문자열 만드는 방향으로 가야함.

#list
여러 개의 값을 순서대로 저장하는 !변경 가능!한 시퀀스 자료형
변경 가능!!!

## 리스트표현
- 0개 이상의 객체를 포함하며 데이터 목록을 저장
- 대괄호([])로 표기
- 데이터는 어떤 자료형도 저장 가능
my_list_1 = [] (빈리스트 가능!!)
my_list_3 = 1,2,3,'python',['hello','world','!!']
len(my_list_3) = 5
print(my_list[4][-1] = !!!)
print(my_list[-1][1][0]) = w

### 리스트는 가변(변경 가능)

my_list = [1,2,3]
my_list[0] = 100
print(my_list) = [100,2,3]

## tuple
여러 개의 값을 순서대로 저장하는 !변경 불가능한! 시퀀스 자료형

- 0개 이상의 객체를 포함하며 데이터 목록을 저장
 - (()) 소괄호로 표기
 - 데이터는 어떤 자료형도 저장할 수 있음

 tuple_1 = ()
 tuple_2 = (1,)
 tuple_3 = (1,'a',3,'b',5)

 튜플 요소가 아니라면 반드시 콤마 붙여줘야 한다!!!!
 튜플괄호가 아니라 연산 묶어주는 괄호로 묶어줄 가능성 있기 때문

tuple-3[1] = 'z'
TypeErroer: 'tuple' object~~

### 튜플은 어디에 쓰일까?
튜플은 불변 특성을 사용한 안전하게 여러 개의 값을 전달, 그룹화, !다중 할당 등 개발자가 직접 사용하기 보다 '파이썬 내부동작'에서 주로 사용!됨.

### 파이썬은 쉼표를 튜플 생성자로 사용하니 괄호는 생략가능

x,y = 10,20
!!위도 튜플이다!!
튜플

문제풀이 절대 쓸 일 없어.

### range
연속된 정수 시퀀스를 생성하는 !변경 불가능!한 자료형
1,2,3,4

### range 표현
 - range(n)
  - 0부터 n-1까지의 숫자의 시퀀스
 - range(n,m)
  - n부터 m-1까지 숫자 시퀀스

갯수는 n개, m-n개

my_range_1 = range(5)
my_range_2 = rage(1,10)

print(my_range_1) # range(0,5)
 
리스트로 형 변환 시 데이터 확인 가능
print(list(my_range_1)) #[0,1,2,3,4]
print(list(my_range_2)) #

### sequence types 특징
인덱싱, 슬라이싱, 길이, 반복
불변형 문자열, 튜플, 레인지
가변형 리스트






### nonsequence types
### dict
- key-value 쌍으로 이루어진 !순서와 중복이 없는! !변경 가능!한 자료형 

- key는 변경 불가능한 자료형만 사용 가능 (str,int,float, tuple,range...) sequence types들은 자료형 상관 없었음.

- value는 모든 자료형 사용 가능
중괄호({})로 표기

my_dict_1 = {}

## 딕셔너리 사용
- key를 통해 value에 접근
my_dict_2 = {'apple':12, 'list' : [1,2,3]}

print(my_dict['apple']) #12
print(my_dict['list']) #[1,2,3]

### 값 변경
my_dict['apple'] = 100
print(my_dict_3) #{'apple':12, 'list':[1,2,3]}

dict 키-밸류 셋트 삭제는 가능
key 변경은 불가능함.

### set 세트
!순서와 중복이 없는! 변경 가능한 자료형

- 수학에서의 집합과 동일한 연산 처리 가능
- 중괄호{}로 표기 -> dict도 중괄호 표기!!!
dict는 빈괄호 만들때 {}이렇게 만들었는데

my_set_1 = set()

set는 빈 set만들때 set()함수 호출

my_set_2 = {1,2,3}
my_set_3 = {1,1,1}

print(my_set_1) #set()
print(my_set_2) #{1,2,3}
print(my_set_3) # {1}

my_set_3보면 순서와 !중복!이 없는 특징 떄문에 다 쳐내고 {1}만 남긴 것.

중복제거를 간편하게 일시적으로 할 수 있어!!!

{1,2,3}은 몇번째 요소인가.
순서가 없기 때문에 몇 번째라는게 없다.
순서가 없다는 건 인덱스가 없다는 뜻!!!


### 세트 집합 연산

합집합
print(my_set_1 | my_set_2)
#{1,2,3,6,9}
print(mu_set - my_set_2)
#{1,2}
print(my_set_1 & my_set_2)
#{3}

### Other Types

### None
파이썬에서 '값이 없음'을 표현하는 자료형

variable = None
print(variable) #None

Boolean 불리언
참과 거짓 표현하는 자료형

- 비교/논리 연산의 평가 결과로 사용됨
- 주로 조건/반복문과 함께 사용

print(3>1) #True
print('3' != 3) (답뭘까?? ㅋㅋㅋ)

## Collection
여러 개의 항목 또는 요소를 담는 자료 구조
str, list, tuple, set, dict


컬렉션 정리 
슬라이드 표 참조 교재 업데이트 필요!!
컬렉션 정렬 여부 -> 나열여부로 바꾸기


   변경가능여부, 나열 여부
set x,o
list o,o
tuple x,o
set o,x\
dict o,x (key는 변경 불가dict만 가능)
나열 o이면 시퀀스
나열 x면 비시퀀스

정열과 나열 차이점??!!

### 불변과 가변의 차이(1/2)

my_str = 'hello'
my-str[0] = 'z'

#타입에러 스트링 객체 아이템 할당 지원x


my_list = [1,2,3]
my_list[0] = 100
print(my_list)
#(100,2,3) 잘 바뀜 리스트는 변경 가능

왜 그런가?
파이썬 튜터 확인

'hello'는 하나의 메모리 주소에 통째로 들어감
'list' 가변은 참조 요소의 방향만 바꾸면 됨.
문자열은 생각외로 쪼객 수 없었음
통쨰로 하나의 메모리 주소에 들어갔기 때문.

가변과 불변의 궁극적인 차이. 값을 어떻게 참조하고 있냐.

리스트는 객체들의 참조를 모아놨다고도 부름. 참조를 모아놓은 컬렉션


### Type conversion
 
### 명시적 형변환
개발자가 직접 형변환 하는 것.
암시적 형변환이 아닌 모든 경우.

str -> inteager: 형식에 맞는 숫자만 가능
integer ->str: 모두 가능
print(int('1')) #1
print(str(1) +'등') #1등
print(float('3.5')) #3.5
print(int(3.5)) #3



#value error뜸 아래 코드.  실제로 쳐보기!!!
print(int(3.5))

p.93 컬렉션간 형변환 정리 표 무조건 나옴!
다른 타입들 range, dict만 형변환 안되고 나머지는 다 가능
dict는 key만 가능
[k,k,k,k,k] list
(k,k,k,k,k) tuple
{k,k,k,k,k} set
중복허용 안하기 때문에

형변환 한다는 건 나중에 쓸모 피요가 이유.
딕셔너리 순회해야하는 경우 키값들만 순회해서 list바꾸거나, 하는 이유
그런 효용성 생각하면 key만 넣는게 맞음



### 암시적 형변환

파이썬에서 알아서 바꾸는 몇가지
Boolean과 Numeric Type에서 가능
print(3+5.0) #8.0
print(True +3) #4
print(True + False) #1


### 연산자

시험에 무조건 나옴!!!!!
is 비교 연산자
- 메모리 내에서 같은 객체를 참조하는지 확인
- ==는 !동등성! is는 !식별성! 아이디까지 동일한지 확인

 2.0 == 2 True
 2.0 is 2 False

 2.0이 저장된 주소값과 2가 저장된 주소값은 다르다
 각자 다른 메모리에 할당되어 있어.
 dust =2.0 호출할때마다 float 호출
 int가 되버리면 원하는대로 동작하지 않을 것.

슬라이드 확인

and 논리곱, or 논리합은 쉽고
not 논리부정- 단일 피연산자를 부정


### 단축평가
논리 연산에서 두번째 피연산자를 평가하지 않고 결과를 결정하는 동작
F AND T일 때 F가 먼저 앞에 오면 무조건 F니까 T는 평가하지 않는 것.

q.다음 중 단축평가 동작하는/하지 않는 것은?


print(3 and 5) #5
print(3 and 0) #0
print(0 an 0) #0 보고 아닌 거바로 앎.

print(3or 0) # 단축 평가 됨.

코드실행 최적화 등이 이유.

### 시퀀스형 연산자는 내일...

 



Boolean과 Numeric

형변환 안되는 것 또는 자동으로 되는 형변환

list_1 = [1,2,3]
list_2 = list_1

list_1[0] = 100
print(list_1) = [100,2,3]

print(list_2) = [1,2,3]이 아니라 
[100,2,3]이 나온다??!!!

리스트 1의 메모리 주소를 할당한 것.
리스트 1메모리 주소의 값이 100으로 변경되니
100,2,3출력 된 것.
가변데이터 복사 되었을 때 주의해야 할 사항!!
가변데이터들의 특징.

나중에 복사라는 주제로 배울 것.

불변은 어떻게 될까?
정수도 불변

x= 10

y= x

x=20
print(x) #20
print(y) #10

파이썬 튜터 많이 활용하기!!
가변/불변데이터 특성 정리


