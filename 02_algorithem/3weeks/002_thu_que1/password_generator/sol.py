




'''
출력
#1 6 2 2 9 4 1 3 0
#2 9 7 9 5 4 3 8 0
#3 8 7 1 6 4 3 5 0
#4 7 5 8 4 8 1 3 0
#5 3 8 7 4 4 7 4 0
#6 6 7 5 9 6 8 5 0
#7 7 6 8 3 2 5 6 0
#8 9 2 1 7 3 6 3 0
#9 4 7 8 1 2 8 4 0
#10 6 8 9 5 8 5 2 0
'''

'''
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.

다음 주어진 조건에 따라 n개의 수를 처리하면 8자리의 암호를 생성할 수 있다.

- 8개의 숫자를 입력 받는다.
- 첫 번째 숫자를 1 감소한 뒤, 맨 뒤로 보낸다. 
다음 첫 번째 수는 2 감소한 뒤 맨 뒤로, 그 다음 첫 번째 수는 3을 감소하고 맨 뒤로, 그 다음 수는 4, 그 다음 수는 5를 감소한다.
이와 같은 작업을 한 사이클이라 한다.
- 숫자가 감소할 때 0보다 작아지는 경우 0으로 유지되며, 프로그램은 종료된다. 이 때의 8자리의 숫자 값이 암호가 된다.

[제약 사항]
주어지는 각 수는 integer 범위를 넘지 않는다.
마지막 암호 배열은 모두 한 자리 수로 구성되어 있다.
 
[입력]
각 테스트 케이스의 첫 줄에는 테스트 케이스의 번호가 주어지고, 그 다음 줄에는 8개의 데이터가 주어진다.
 
[출력]
#부호와 함께 테스트케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스의 답을 출력한다.
'''

'''
1
10 11 12 13 14 15 16 17
'''
import sys
sys.stdin = open('input.txt')

T = 10
for tc in range(1, T+1):
    n = int(input())
    queue = list(map(int, input().split()))

    # while 조건이 true일 때 반복
    # while queue[0] > 0 or queue[1] > 0 or queue[2] > 0 or queue[3] > 0 or queue[4] > 0 or queue[5] > 0 or queue[6] > 0 or queue[7] > 0:
    # 어차피 queue에서 i 만큼 빼고 맨뒤로 보내버리니깐, 맨 뒤 값으로 조건 만들어서 while, for문 만들기.


    while queue[-1] > 0:
        for i in range(1, 6):
            queue[0] -= i
            tmp = queue.pop(0)
            queue.append(tmp)

            if queue[-1] <= 0:
                break

    queue[-1] = 0


    print(f'#{tc} {queue}')



    # 저거 while문 조건 주는게 힘드네 for queue[-1] > 0: 이거는 bool이 반복안된다카고...