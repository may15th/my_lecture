설계부터 해라 그림부터 그려라
1. 문제 해석
- 문제에서 원하는 목표가 무엇인가.
-> 명확하게 문제를 파악해야 함.

--------------------------------------- 예시
- 높이가 b인 선반
- 선반
 - 선반 높이 b모두 접근 가능

- 점원(키 Hj)
 - 점원들은 불가. 각 점원 키 Hi 탑을 쌓아서 선반 위 물건 사용
 - 탑을 쌓는 방법
  - 1명 : 점원의 키 == 탑의 높이
  - 2명 이상 : 점원 키의 합 == 탑의 높이
     => 선반보다 높거나 같을 경우 물건을 쓸 수 있음.

높이가 B 이상인 탑 중에서, 높이가 가장 낮은 탑을 구하라.


----------------------------------- 문제 해석 완료

2. 무슨 알고리즘을 쓸까? ************* 이 부분이 중요.

B가 10이라고 할 때 3,4,5 쌓아보고, 4,5,6 쌓아보고...
이런 게 뭐냐? -> 조합 사용해야겠다.
이런 식

시뮬레이션을 해보니, 미리 무언가르 구할 수가 없다!
 -> 모든 경우의 수를 보아야 한다.
 -> 완전 탐색 문제이다 라고 생각하고 접근

{1,2,3,4}
DFS => 경우의 수 : O(N!)

- 먼저 떠오르는 알고리즘 있다면, 시간을 먼저 계산

채점을 하고 있는데
운영체제가 WINDOW95면 오래 걸리겠지
WINDOW11이면 빠르겠지

코딩테스트 문제 전용
C/C++ : 1초 = 대략 1억번

PYTHON : 대략 1초 : 2000만번 (3~4배 정도 느리기 때문)

팩토리얼의 경우 N이 11을 넘어가네? 11! 대략 4천만 이기때문에 n =10!까지만 가능

완전 탐색 풀어보면 N값이 대략 9~10사이다



*꿀팁*
장훈이 선반문제는 N<=20이기 때문에 완전 탐색 돌리면 안되는구나!
알 수 있음
-> 시간초과가 난다.

-조합론에서 배운 다른 개념 사용하자!
-> Backtracking!!! N =20~30 문제는 대부분 백트래킹으로 해결함.
-> 획기적으로 완전 탐색에서 경우의 수 줄여보자.

백트래킹 방법
재귀 돌리다가 => 이미 탑 높이보다 더 높네? 바로 가지치기 쓰기

코딩보다 설계가 훨씬 중요. 문제 풀이 확신을 가지는 게 중요




1238_ contact

빨간색 2번이 시작 7,15가 1번이겠네.
알고리즘 뭐 알고 있나?
BFS!, 특정노드 기준 갈 수 있는 곳 다 가면서 채워 나가는 식 -> BFS네,
화살표 있는 거 보니-> 단방향 그래프네

이미 연락을 받은 사애익 떄문에 다시 연락하지 않는다
-> visited 써라는 뜻.

중간 중간 비어있는 번호가 있을 수 있다 의 의미?
-> 중간 비어있는 거 쓰면 안좋아 -> 인접리스트로 해 라고 귀띔을 준거.
-> 인접 행렬로 하면 0 들어가는 것들 떄문에 속도 느려 질 것.


수업전체 정리
0. ide를 적극적으로 활용해라
 - input.in 써서, 복사하지 말고 사용
 - 디버깅 툴 -> 적극적으로 써라

기업테스트 프로그래머스 많이 쓴다고 함.
디버깅 툴 제공 안해줘.
디버깅 할 때 프린트로 다 찍어서 해야 함.
-> print로 다 디버깅?
-> 적재 적소에 print를 사용할 줄 알아야 함.
-> 디버깅 툴을 활용해서 연습 breakpoint도. 여기다가 중단점 걸면 좋구나. 출력을 여기서 보면 좋구나...

1. 완전 탐색
 - > 문제를 봤을 때 원하는 알고리즘 선택해야 하는데, 

1.1 일단 완전 탐색으로 생각해봐라. 다돌려서 해결할 수 있으면 좋지
여기서 N값을 반드시 확인해서, 시간복잡도를 확인.

1.2. 시간복잡도 때문에 안 될 경우

-> backtrackin하는 방법 생각

1.3. 조금 더 어려운 알고리즘

- 그리디 (규칙 찾기)
- dp( 두 번 계산하지 않기)
- union_find 




==================시험 준비=======
비트연산자가 뭐가 있는지
비트연산을 보라는게 아니라 비트연산자 뭐가 있는지 보라는데...
1 << 3 1을 왼쪽으로 3번 시프트하면 1000(2)라서 8
10 & 2 연산 하면 2
10은 1010(2) 2는 10(2) 이기 때문에 and연산하면 10(2) 라서 2
10|2(or연산) 하면 10이 나옴
1010(2) 10(2)이라서 10

10^2(xor연산)
1010(2) 0010이라서 1000 = 8

10^3은 9가나옴

논리와 증명
computational thinking파트
p - q = &
증명은 역, 이, 대우로 한다

증명은 대우를 사용해서 한다

n=3k+1,3k+2이면 3의 배수가 아닌 것.

computational thinking논리와 증명 파트 보면된다.

그 다음에 최소생산 비용 풀면 100점!!
solving_club extra five 답안도 있으니 확인하기!



비트연산 : & | ^ >> 가 어떻게 작동하는지 안다,
-> python ide 켜서 결과 보고 왜 그렇게 되는지 이해하면 됩니다.

